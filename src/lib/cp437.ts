/**
 * CP437 (Code Page 437) to Unicode mapping table.
 * This is the original IBM PC character set used by NFO files.
 * Characters 0x00-0x1F map to special graphical symbols instead of control codes.
 */
const CP437_TO_UNICODE: number[] = [
  // 0x00 - 0x0F
  0x0000, 0x263A, 0x263B, 0x2665, 0x2666, 0x2663, 0x2660, 0x2022,
  0x25D8, 0x25CB, 0x25D9, 0x2642, 0x2640, 0x266A, 0x266B, 0x263C,
  // 0x10 - 0x1F
  0x25BA, 0x25C4, 0x2195, 0x203C, 0x00B6, 0x00A7, 0x25AC, 0x21A8,
  0x2191, 0x2193, 0x2192, 0x2190, 0x221F, 0x2194, 0x25B2, 0x25BC,
  // 0x20 - 0x7E: Standard ASCII (identity mapping)
  ...Array.from({ length: 95 }, (_, i) => 0x20 + i),
  // 0x7F
  0x2302,
  // 0x80 - 0x8F
  0x00C7, 0x00FC, 0x00E9, 0x00E2, 0x00E4, 0x00E0, 0x00E5, 0x00E7,
  0x00EA, 0x00EB, 0x00E8, 0x00EF, 0x00EE, 0x00EC, 0x00C4, 0x00C5,
  // 0x90 - 0x9F
  0x00C9, 0x00E6, 0x00C6, 0x00F4, 0x00F6, 0x00F2, 0x00FB, 0x00F9,
  0x00FF, 0x00D6, 0x00DC, 0x00A2, 0x00A3, 0x00A5, 0x20A7, 0x0192,
  // 0xA0 - 0xAF
  0x00E1, 0x00ED, 0x00F3, 0x00FA, 0x00F1, 0x00D1, 0x00AA, 0x00BA,
  0x00BF, 0x2310, 0x00AC, 0x00BD, 0x00BC, 0x00A1, 0x00AB, 0x00BB,
  // 0xB0 - 0xBF (box drawing light)
  0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561, 0x2562, 0x2556,
  0x2555, 0x2563, 0x2551, 0x2557, 0x255D, 0x255C, 0x255B, 0x2510,
  // 0xC0 - 0xCF
  0x2514, 0x2534, 0x252C, 0x251C, 0x2500, 0x253C, 0x255E, 0x255F,
  0x255A, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550, 0x256C, 0x2567,
  // 0xD0 - 0xDF
  0x2568, 0x2564, 0x2565, 0x2559, 0x2558, 0x2552, 0x2553, 0x256B,
  0x256A, 0x2518, 0x250C, 0x2588, 0x2584, 0x258C, 0x2590, 0x2580,
  // 0xE0 - 0xEF
  0x03B1, 0x00DF, 0x0393, 0x03C0, 0x03A3, 0x03C3, 0x00B5, 0x03C4,
  0x03A6, 0x0398, 0x03A9, 0x03B4, 0x221E, 0x03C6, 0x03B5, 0x2229,
  // 0xF0 - 0xFF
  0x2261, 0x00B1, 0x2265, 0x2264, 0x2320, 0x2321, 0x00F7, 0x2248,
  0x00B0, 0x2219, 0x00B7, 0x221A, 0x207F, 0x00B2, 0x25A0, 0x00A0,
];

/** Decode a CP437 byte array to a Unicode string */
export function decodeCP437(bytes: Uint8Array): string {
  const chars: string[] = [];
  for (let i = 0; i < bytes.length; i++) {
    const byte = bytes[i];
    // Preserve CR/LF/TAB as-is
    if (byte === 0x0A || byte === 0x0D || byte === 0x09) {
      chars.push(String.fromCharCode(byte));
    } else {
      chars.push(String.fromCodePoint(CP437_TO_UNICODE[byte]));
    }
  }
  return chars.join('');
}

/** Detect if a buffer is likely CP437 encoded (vs UTF-8) */
export function isLikelyCP437(bytes: Uint8Array): boolean {
  // If it has a UTF-8 BOM, it's UTF-8
  if (bytes.length >= 3 && bytes[0] === 0xEF && bytes[1] === 0xBB && bytes[2] === 0xBF) {
    return false;
  }

  let highBytes = 0;
  let invalidUtf8 = 0;

  for (let i = 0; i < bytes.length; i++) {
    const b = bytes[i];
    if (b >= 0x80) {
      highBytes++;
      // Check if valid UTF-8 multi-byte sequence
      if (b >= 0xC0 && b < 0xE0) {
        if (i + 1 >= bytes.length || (bytes[i + 1] & 0xC0) !== 0x80) {
          invalidUtf8++;
        } else {
          i += 1;
        }
      } else if (b >= 0xE0 && b < 0xF0) {
        if (i + 2 >= bytes.length || (bytes[i + 1] & 0xC0) !== 0x80 || (bytes[i + 2] & 0xC0) !== 0x80) {
          invalidUtf8++;
        } else {
          i += 2;
        }
      } else if (b >= 0x80 && b < 0xC0) {
        // Standalone continuation byte â€” invalid UTF-8
        invalidUtf8++;
      }
    }
  }

  // If there are high bytes and many are invalid UTF-8, it's likely CP437
  if (highBytes === 0) return false;
  return invalidUtf8 / highBytes > 0.3;
}

/** Smart decode: auto-detect encoding and decode accordingly */
export function smartDecode(bytes: Uint8Array): string {
  if (isLikelyCP437(bytes)) {
    return decodeCP437(bytes);
  }
  // Strip UTF-8 BOM if present
  const decoder = new TextDecoder('utf-8');
  return decoder.decode(bytes);
}
